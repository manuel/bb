;; Store interface - a simple hierarchical filesystem storing strings
(define-prototype Store Object ())
(define-generic (make-tx store))
(define-prototype StoreTx Object ())
(define-generic (get-file tx path))
(define-generic (put-file tx path content))
(define-generic (delete-file tx path))
(define-generic (commit tx))
(define-prototype Path Object (elements))
(define (make-path . elements)
  (new Path (list-to-array (map-list (lambda (e) (the String e)) elements))))

;; LocalStorage implementation of Store - no transactions
(define-prototype LocalStore Store ())
(define-prototype LocalTx StoreTx (store))
(define (make-local-store) (new LocalStore))
(define-method (make-tx (store LocalStore))
  (new LocalTx store))
(define (local-store-check-path (path Path))
  (unless (= 1 (.length (.elements path)))
    (error "Only supports one path element currently.")))
(define-method (get-file (tx LocalTx) (path Path))
  (local-store-check-path path)
  (@getItem $localStorage (elt (.elements path) 0)))
(define-method (put-file (tx LocalTx) (path Path) (content String))
  (local-store-check-path path)
  (@setItem $localStorage (elt (.elements path) 0) content))
(define-method (delete-file (tx LocalTx) (path Path))
  (local-store-check-path path)
  (@removeItem $localStorage (elt (.elements path) 0)))
(define-method (commit (tx LocalTx)))

;; Unofficial way to get all paths in a store
(define-generic (for-each-path tx fun))
(define-method (for-each-path (tx LocalTx) fun)
  (let ((i (cell 0)))
    (while (< (ref i) (.length $localStorage))
      (fun (make-path (@key $localStorage (ref i))))
      (++ (ref i)))))

;; Space interface - graph store
(define-prototype Space Object ())
(define-prototype SpaceTx Object ())
(define-generic (get-entry space-tx path))
(define-generic (put-entry space-tx path entry))
(define-generic (delete-entry space-tx path))
(define-prototype Entry Object (links))
(define-prototype Link Object (rel src dst))
(define-prototype End Object (href))
(define (make-entry (links Array)) (new Entry (map-array (lambda (l) (the Link l)) links)))
(define (make-link rel (src End) (dst End)) (new Link rel src dst))
(define (make-end href) (new End href))
(define-prototype Feed Object (entries))
(define (make-feed (entries Array)) (new Feed entries))
(define-generic (get-out-links space-tx path rel))
(define-generic (get-in-links space-tx path rel))

(define (get-or-create-entry (tx SpaceTx) (path Path))
  (let ((e (get-entry tx path)))
    (if (= #null e)
        (make-entry (array))
        e)))

;; Simple space implementation backed by a store using verbose JSON-encoded Transit format
(define-prototype SimpleSpace Space (store))
(define-prototype SimpleSpaceTx SpaceTx (storeTx))
(define (make-simple-space (store Store)) (new SimpleSpace store))
(define-method (make-tx (space SimpleSpace)) (new SimpleSpaceTx (make-tx (.store space))))
(define-method (get-entry (space-tx SimpleSpaceTx) (path Path))
  (let ((content (get-file (.storeTx space-tx) path)))
    (if (= #null content)
        #null
        (string->entry content))))
(define-method (put-entry (space-tx SimpleSpaceTx) (path Path) (entry Entry))
  (put-file (.storeTx space-tx) path (entry->string entry)))
(define-method (delete-entry (space-tx SimpleSpaceTx) (path Path))
  (delete-file (.storeTx space-tx) path))
(define-method (get-out-links (space-tx SimpleSpaceTx) (src Path) rel)
  (let ((entry (get-entry space-tx src)))
    (make-feed 
     (if (= #null entry)
         (array)
         (array-keep (lambda (link) (data-equal (.rel link) rel))
                     (.links entry))))))
(define-method (for-each-path (space-tx SimpleSpaceTx) fun)
  (for-each-path (.storeTx space-tx) fun))
(define-method (get-in-links (space-tx SimpleSpaceTx) (dst Path) rel)
  (define in-links (array))
  (for-each-path space-tx (lambda ((src Path))
                            (let ((out-links (get-out-links space-tx src rel)))
                              (map-array (lambda (out-link)
                                           (when (data-equal (.href (.dst out-link)) dst)
                                             (@push in-links out-link)))
                                         (.entries out-links)))))
  (make-feed in-links))

(define (entry->string (entry Entry)) (encode-transit (->transit entry)))
(define (string->entry (content String)) (transit->entry (decode-transit content)))

;; Transit encoding 
(define (encode-transit transit) (@stringify $JSON transit))
(define-generic (->transit obj))
(define-method (->transit (entry Entry))
  (object
   ("links" (map-array ->transit (.links entry)))))
(define-method (->transit (link Link))
  (object
   ("rel" (->transit (.rel link)))
   ("src" (->transit (.src link)))
   ("dst" (->transit (.dst link)))))
(define-method (->transit (end End))
  (object
   ("href" (->transit (.href end)))))
(define-method (->transit (string String)) string)
(define-method (->transit (array Array)) (map-array ->transit array))
(define +transit-path+ "~#path")
(define-method (->transit (path Path))
  (object (+transit-path+ (map-array ->transit (.elements path)))))

;; Transit decoding
(define (decode-transit (content String)) (@parse $JSON content))
(define (transit->entry transit)
  (let ((links (the Array (.links transit))))
    (make-entry (map-array transit->link links))))
(define (transit->link transit)
  (make-link (transit->data (.rel transit))
             (transit->end (.src transit))
             (transit->end (.dst transit))))
(define (transit->end transit)
  (make-end (transit->data (.href transit))))
(define (transit->data transit)
  (cond ((type? transit String)
         (transit->string transit))
        ((type? transit Array)
         (transit->array transit))
        ((and (type? transit Object) (@hasOwnProperty transit +transit-path+))
         (transit->path transit))
        (else (error (+ "Unknown data: " transit)))))
(define (transit->string (transit String)) transit)
(define (transit->array (transit Array)) (map-array transit->data transit))
(define (transit->path (transit Object))
  (apply make-path (map-list transit->data (array-to-list (elt transit +transit-path+)))))

;; Session - a browsing and editing context that may consist of
;; multiple spaces
(define-prototype Session Object ())
(define-generic (session-space session))

;; Trivial session - simply presents a single space as a session
(define-prototype TrivialSession Session (space))
(define (make-trivial-session (space Space)) (new TrivialSession space))
(define-method (session-space (session TrivialSession)) (.space session))

;; Hack
(define (data-equal a b)
  (= (encode-transit (->transit a)) (encode-transit (->transit b))))
